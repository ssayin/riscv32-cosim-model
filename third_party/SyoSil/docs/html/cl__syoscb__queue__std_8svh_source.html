<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>SyoSil ApS UVM Scoreboard: cl_syoscb_queue_std.svh Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="dir_562324e130495ce1321e3e3f14c8d761.html">src</a>
  </div>
</div>
<div class="contents">
<h1>cl_syoscb_queue_std.svh</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/// Standard implementation of a queue. Uses a normal SystemVerilog queue as</span>
<a name="l00002"></a>00002 <span class="comment"></span><span class="comment">/// implementation. The class implements the queue API as defined by the queue</span>
<a name="l00003"></a>00003 <span class="comment"></span><span class="comment">/// base class.</span>
<a name="l00004"></a><a class="code" href="classcl__syoscb__queue__std.html">00004</a> <span class="comment"></span><span class="keyword">class </span><a class="code" href="classcl__syoscb__queue__std.html" title="Standard implementation of a queue.">cl_syoscb_queue_std</a> <span class="keyword">extends</span> <a class="code" href="classcl__syoscb__queue.html" title="Class which base concet of a queue.">cl_syoscb_queue</a>;
<a name="l00005"></a>00005   <span class="comment">//-------------------------------------</span>
<a name="l00006"></a>00006   <span class="comment">// Non randomizable variables</span>
<a name="l00007"></a>00007   <span class="comment">//-------------------------------------</span><span class="comment"></span>
<a name="l00008"></a>00008 <span class="comment">  /// Poor mans queue implementation as a SV queue</span>
<a name="l00009"></a>00009 <span class="comment"></span>  local <a class="code" href="classcl__syoscb__item.html" title="The UVM scoreboard item.">cl_syoscb_item</a> items[$];
<a name="l00010"></a>00010 
<a name="l00011"></a>00011   <span class="comment">//-------------------------------------</span>
<a name="l00012"></a>00012   <span class="comment">// UVM Macros</span>
<a name="l00013"></a>00013   <span class="comment">//-------------------------------------</span>
<a name="l00014"></a>00014   `uvm_component_utils_begin(cl_syoscb_queue_std)
<a name="l00015"></a>00015     `uvm_field_queue_object(items, UVM_DEFAULT)
<a name="l00016"></a>00016   `uvm_component_utils_end
<a name="l00017"></a>00017 
<a name="l00018"></a>00018   <span class="comment">//-------------------------------------</span>
<a name="l00019"></a>00019   <span class="comment">// Constructor</span>
<a name="l00020"></a>00020   <span class="comment">//-------------------------------------</span>
<a name="l00021"></a>00021   extern function new(string name, uvm_component parent);
<a name="l00022"></a>00022 
<a name="l00023"></a>00023   <span class="comment">//-------------------------------------</span>
<a name="l00024"></a>00024   <span class="comment">// Queue API</span>
<a name="l00025"></a>00025   <span class="comment">//-------------------------------------</span>
<a name="l00026"></a>00026   <span class="comment">// Basic queue functions</span>
<a name="l00027"></a>00027   extern <span class="keyword">virtual</span> function bit <a class="code" href="classcl__syoscb__queue__std.html#a68f61e7f53901acb3cc50a9001193c0f" title="Queue API: See cl_syoscb_queue for more details">add_item</a>(string producer, uvm_sequence_item item);
<a name="l00028"></a>00028   extern <span class="keyword">virtual</span> function bit <a class="code" href="classcl__syoscb__queue__std.html#a9cae04fa7b9a40a5554ef24bfaac851b" title="Queue API: See cl_syoscb_queue for more details">delete_item</a>(int unsigned idx);
<a name="l00029"></a>00029   extern <span class="keyword">virtual</span> function <a class="code" href="classcl__syoscb__item.html" title="The UVM scoreboard item.">cl_syoscb_item</a> <a class="code" href="classcl__syoscb__queue__std.html#a42efb916d933e56e9865919504054499" title="Queue API: See cl_syoscb_queue for more details">get_item</a>(int unsigned idx);
<a name="l00030"></a>00030   extern <span class="keyword">virtual</span> function int unsigned <a class="code" href="classcl__syoscb__queue__std.html#ac91a26574353c8c24789a993d3ffc12d" title="Queue API: See cl_syoscb_queue for more details">get_size</a>();
<a name="l00031"></a>00031   extern <span class="keyword">virtual</span> function bit <a class="code" href="classcl__syoscb__queue__std.html#a812d7f4d7143c9bef1f3181e24347d5c" title="Queue API: See cl_syoscb_queue for more details">empty</a>();
<a name="l00032"></a>00032   extern <span class="keyword">virtual</span> function bit <a class="code" href="classcl__syoscb__queue__std.html#ad293b78071120f596e3884980e36a9fa" title="Queue API: See cl_syoscb_queue for more details">insert_item</a>(string producer, uvm_sequence_item item, int unsigned idx);
<a name="l00033"></a>00033 
<a name="l00034"></a>00034   <span class="comment">// Iterator support functions</span>
<a name="l00035"></a>00035   extern <span class="keyword">virtual</span> function <a class="code" href="classcl__syoscb__queue__iterator__base.html" title="Queue iterator base class defining the iterator API used for iterating queues.">cl_syoscb_queue_iterator_base</a> <a class="code" href="classcl__syoscb__queue__std.html#a84149180e88153757ac3df08fe6dd3ce" title="Queue API: See cl_syoscb_queue for more details">create_iterator</a>();
<a name="l00036"></a>00036   extern <span class="keyword">virtual</span> function bit <a class="code" href="classcl__syoscb__queue__std.html#ada80798fcd391e309e0e85f68cda98e1" title="Queue API: See cl_syoscb_queue for more details">delete_iterator</a>(cl_syoscb_queue_iterator_base iterator);
<a name="l00037"></a>00037 endclass: <a class="code" href="classcl__syoscb__queue__std.html" title="Standard implementation of a queue.">cl_syoscb_queue_std</a>
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 function <a class="code" href="classcl__syoscb__queue__std.html" title="Standard implementation of a queue.">cl_syoscb_queue_std</a>::new(string name, uvm_component parent);
<a name="l00040"></a>00040   super.new(name, parent);
<a name="l00041"></a>00041 endfunction: new
<a name="l00042"></a>00042 <span class="comment"></span>
<a name="l00043"></a>00043 <span class="comment">/// &lt;b&gt;Queue API:&lt;/b&gt; See cl_syoscb_queue for more details</span>
<a name="l00044"></a><a class="code" href="classcl__syoscb__queue__std.html#a68f61e7f53901acb3cc50a9001193c0f">00044</a> <span class="comment"></span>function bit <a class="code" href="classcl__syoscb__queue__std.html" title="Standard implementation of a queue.">cl_syoscb_queue_std</a>::<a class="code" href="classcl__syoscb__queue__std.html#a68f61e7f53901acb3cc50a9001193c0f" title="Queue API: See cl_syoscb_queue for more details">add_item</a>(string producer, uvm_sequence_item item);
<a name="l00045"></a>00045   <a class="code" href="classcl__syoscb__item.html" title="The UVM scoreboard item.">cl_syoscb_item</a> new_item;
<a name="l00046"></a>00046 
<a name="l00047"></a>00047   <span class="comment">// Check that the max_queue_size for this queue is not reached</span>
<a name="l00048"></a>00048   if(this.cfg.get_max_queue_size(this.get_name())&gt;0 &amp;&amp;
<a name="l00049"></a>00049      this.<a class="code" href="classcl__syoscb__queue__std.html#ac91a26574353c8c24789a993d3ffc12d" title="Queue API: See cl_syoscb_queue for more details">get_size</a>()==this.<a class="code" href="classcl__syoscb__queue.html#ab92efb1fb67ec7cc8dfe928a474a3e2b" title="Handle to the configuration.">cfg</a>.get_max_queue_size(this.get_name())) begin
<a name="l00050"></a>00050     `uvm_error(&quot;QUEUE_ERROR&quot;, $sformatf(&quot;Maximum number of items (%0d) for queue: %s reached&quot;,
<a name="l00051"></a>00051                                        this.cfg.get_max_queue_size(this.get_name()),
<a name="l00052"></a>00052                                        this.get_name()))
<a name="l00053"></a>00053     return(1&apos;b0);
<a name="l00054"></a>00054   end
<a name="l00055"></a>00055 
<a name="l00056"></a>00056   <span class="comment">// Create the new scoreboard item with META data which wraps the</span>
<a name="l00057"></a>00057   <span class="comment">// uvm_sequence_item</span>
<a name="l00058"></a>00058   <span class="comment">//</span>
<a name="l00059"></a>00059   <span class="comment">// *NOTE*: No need for using create.</span>
<a name="l00060"></a>00060   <span class="comment">//         New is okay since no customization is needed here</span>
<a name="l00061"></a>00061   <span class="comment">//</span>
<a name="l00062"></a>00062   <span class="comment">// *NOTE*: Create it once with a default name to be able to retrieve the unique</span>
<a name="l00063"></a>00063   <span class="comment">//         instance id and then rename the object with a uniqueue name</span>
<a name="l00064"></a>00064   new_item = new(.name(&quot;default-item&quot;));
<a name="l00065"></a>00065   new_item.set_name({producer,&quot;-item-&quot;, $psprintf(&quot;%0d&quot;, new_item.get_inst_id())});
<a name="l00066"></a>00066 
<a name="l00067"></a>00067   <span class="comment">// Transfer the producer to the item</span>
<a name="l00068"></a>00068   <span class="comment">// *NOTE*: No need to check the producer since this is checked by the parent component</span>
<a name="l00069"></a>00069   new_item.set_producer(.producer(producer));
<a name="l00070"></a>00070 
<a name="l00071"></a>00071   <span class="comment">// Transfer the UVM sequence item to the item</span>
<a name="l00072"></a>00072   <span class="comment">// *NOTE*: No need to copy it since it has been copied by the parent</span>
<a name="l00073"></a>00073   new_item.set_item(.item(item));
<a name="l00074"></a>00074 
<a name="l00075"></a>00075   <span class="comment">// Insert the item in the queue</span>
<a name="l00076"></a>00076   this.items.push_back(new_item);
<a name="l00077"></a>00077 
<a name="l00078"></a>00078   <span class="comment">// Signal that it worked</span>
<a name="l00079"></a>00079   return 1;
<a name="l00080"></a>00080 endfunction: <a class="code" href="classcl__syoscb__queue__std.html#a68f61e7f53901acb3cc50a9001193c0f" title="Queue API: See cl_syoscb_queue for more details">add_item</a>
<a name="l00081"></a>00081 <span class="comment"></span>
<a name="l00082"></a>00082 <span class="comment">/// &lt;b&gt;Queue API:&lt;/b&gt; See cl_syoscb_queue for more details</span>
<a name="l00083"></a><a class="code" href="classcl__syoscb__queue__std.html#a9cae04fa7b9a40a5554ef24bfaac851b">00083</a> <span class="comment"></span>function bit <a class="code" href="classcl__syoscb__queue__std.html" title="Standard implementation of a queue.">cl_syoscb_queue_std</a>::<a class="code" href="classcl__syoscb__queue__std.html#a9cae04fa7b9a40a5554ef24bfaac851b" title="Queue API: See cl_syoscb_queue for more details">delete_item</a>(int unsigned idx);
<a name="l00084"></a>00084   if(idx &lt; this.items.size()) begin
<a name="l00085"></a>00085     cl_syoscb_queue_iterator_base iter[$];
<a name="l00086"></a>00086 
<a name="l00087"></a>00087     <span class="comment">// Wait to get exclusive access to the queue</span>
<a name="l00088"></a>00088     <span class="comment">// if there are multiple iterators</span>
<a name="l00089"></a>00089     while(!this.iter_sem.try_get());
<a name="l00090"></a>00090     items.delete(idx);
<a name="l00091"></a>00091 
<a name="l00092"></a>00092     <span class="comment">// Update iterators</span>
<a name="l00093"></a>00093     iter = this.iterators.find(x) with (x.get_idx() &lt; idx);
<a name="l00094"></a>00094     for(int i = 0; i &lt; iter.size(); i++) begin
<a name="l00095"></a>00095       void&apos;(iter[i].previous());
<a name="l00096"></a>00096     end
<a name="l00097"></a>00097 
<a name="l00098"></a>00098     this.iter_sem.put();
<a name="l00099"></a>00099     return 1;
<a name="l00100"></a>00100   end else begin
<a name="l00101"></a>00101     `uvm_info(&quot;OUT_OF_BOUNDS&quot;, $sformatf(&quot;Idx: %0d is not present in queue: %0s&quot;, idx, this.get_name()), UVM_DEBUG);
<a name="l00102"></a>00102     return 0;
<a name="l00103"></a>00103   end
<a name="l00104"></a>00104 endfunction: delete_item
<a name="l00105"></a>00105 <span class="comment"></span>
<a name="l00106"></a>00106 <span class="comment">/// &lt;b&gt;Queue API:&lt;/b&gt; See cl_syoscb_queue for more details</span>
<a name="l00107"></a><a class="code" href="classcl__syoscb__queue__std.html#a42efb916d933e56e9865919504054499">00107</a> <span class="comment"></span>function cl_syoscb_item cl_syoscb_queue_std::get_item(int unsigned idx);
<a name="l00108"></a>00108   if(idx &lt; this.items.size()) begin
<a name="l00109"></a>00109     return items[idx];
<a name="l00110"></a>00110   end else begin
<a name="l00111"></a>00111     `uvm_info(&quot;OUT_OF_BOUNDS&quot;, $sformatf(&quot;Idx: %0d is not present in queue: %0s&quot;, idx, this.get_name()), UVM_DEBUG);
<a name="l00112"></a>00112     return null;
<a name="l00113"></a>00113   end
<a name="l00114"></a>00114 endfunction: get_item
<a name="l00115"></a>00115 <span class="comment"></span>
<a name="l00116"></a>00116 <span class="comment">/// &lt;b&gt;Queue API:&lt;/b&gt; See cl_syoscb_queue for more details</span>
<a name="l00117"></a><a class="code" href="classcl__syoscb__queue__std.html#ac91a26574353c8c24789a993d3ffc12d">00117</a> <span class="comment"></span>function int unsigned cl_syoscb_queue_std::get_size();
<a name="l00118"></a>00118   return this.items.size();
<a name="l00119"></a>00119 endfunction: get_size
<a name="l00120"></a>00120 <span class="comment"></span>
<a name="l00121"></a>00121 <span class="comment">/// &lt;b&gt;Queue API:&lt;/b&gt; See cl_syoscb_queue for more details</span>
<a name="l00122"></a><a class="code" href="classcl__syoscb__queue__std.html#a812d7f4d7143c9bef1f3181e24347d5c">00122</a> <span class="comment"></span>function bit cl_syoscb_queue_std::empty();
<a name="l00123"></a>00123   return(this.get_size()!=0 ? 0 : 1);
<a name="l00124"></a>00124 endfunction
<a name="l00125"></a>00125 <span class="comment"></span>
<a name="l00126"></a>00126 <span class="comment">/// &lt;b&gt;Queue API:&lt;/b&gt; See cl_syoscb_queue for more details</span>
<a name="l00127"></a><a class="code" href="classcl__syoscb__queue__std.html#ad293b78071120f596e3884980e36a9fa">00127</a> <span class="comment"></span>function bit cl_syoscb_queue_std::insert_item(string producer, uvm_sequence_item item, int unsigned idx);
<a name="l00128"></a>00128   cl_syoscb_item new_item;
<a name="l00129"></a>00129 
<a name="l00130"></a>00130   <span class="comment">// Create the new scoreboard item with META data which wraps the</span>
<a name="l00131"></a>00131   <span class="comment">// uvm_sequence_item</span>
<a name="l00132"></a>00132   <span class="comment">//</span>
<a name="l00133"></a>00133   <span class="comment">// *NOTE*: No need for using create.</span>
<a name="l00134"></a>00134   <span class="comment">//         New is okay since no customization is needed here</span>
<a name="l00135"></a>00135   <span class="comment">//</span>
<a name="l00136"></a>00136   <span class="comment">// *NOTE*: Create it once with a default name to be able to retrieve the unique</span>
<a name="l00137"></a>00137   <span class="comment">//         instance id and then rename the object with a uniqueue name</span>
<a name="l00138"></a>00138   new_item = new(.name(&quot;default-item&quot;));
<a name="l00139"></a>00139   new_item.set_name({producer,&quot;-item-&quot;, $psprintf(&quot;%0d&quot;, new_item.get_inst_id())});
<a name="l00140"></a>00140 
<a name="l00141"></a>00141   <span class="comment">// Transfer the producer to the item</span>
<a name="l00142"></a>00142   <span class="comment">// *NOTE*: No need to check the producer since this is checked by the parent component</span>
<a name="l00143"></a>00143   new_item.set_producer(.producer(producer));
<a name="l00144"></a>00144 
<a name="l00145"></a>00145   <span class="comment">// Transfer the UVM sequence item to the item</span>
<a name="l00146"></a>00146   <span class="comment">// *NOTE*: No need to copy it since it has been copied by the parent</span>
<a name="l00147"></a>00147   new_item.set_item(.item(item));
<a name="l00148"></a>00148 
<a name="l00149"></a>00149   if(idx &lt; this.items.size()) begin
<a name="l00150"></a>00150     cl_syoscb_queue_iterator_base iter[$];
<a name="l00151"></a>00151 
<a name="l00152"></a>00152     <span class="comment">// Wait to get exclusive access to the queue</span>
<a name="l00153"></a>00153     <span class="comment">// if there are multiple iterators</span>
<a name="l00154"></a>00154     while(!this.iter_sem.try_get());
<a name="l00155"></a>00155     this.items.insert(idx, new_item);
<a name="l00156"></a>00156 
<a name="l00157"></a>00157     <span class="comment">// Update iterators</span>
<a name="l00158"></a>00158     iter = this.iterators.find(x) with (x.get_idx() &gt;= idx);
<a name="l00159"></a>00159     for(int i = 0; i &lt; iter.size(); i++) begin
<a name="l00160"></a>00160       <span class="comment">// Call .next() blindly. This can never fail by design, since</span>
<a name="l00161"></a>00161       <span class="comment">// if it was point at the last element then it points to the second last</span>
<a name="l00162"></a>00162       <span class="comment">// element prior to the .next(). The .next() call will then just</span>
<a name="l00163"></a>00163       <span class="comment">// set the iterator to the correct index again after the insertion</span>
<a name="l00164"></a>00164       void&apos;(iter[i].next());
<a name="l00165"></a>00165     end
<a name="l00166"></a>00166 
<a name="l00167"></a>00167     this.iter_sem.put();
<a name="l00168"></a>00168     return 1;
<a name="l00169"></a>00169   end else if(idx == this.items.size()) begin
<a name="l00170"></a>00170     this.items.push_back(new_item);
<a name="l00171"></a>00171     return 1;
<a name="l00172"></a>00172   end else begin
<a name="l00173"></a>00173     `uvm_info(&quot;OUT_OF_BOUNDS&quot;, $sformatf(&quot;Idx: %0d too large for queue %0s&quot;, idx, this.get_name()), UVM_DEBUG);
<a name="l00174"></a>00174     return 0;
<a name="l00175"></a>00175   end
<a name="l00176"></a>00176 endfunction: insert_item
<a name="l00177"></a>00177 
<a name="l00178"></a>00178 <span class="comment"></span>
<a name="l00179"></a>00179 <span class="comment">/// &lt;b&gt;Queue API:&lt;/b&gt; See cl_syoscb_queue for more details</span>
<a name="l00180"></a><a class="code" href="classcl__syoscb__queue__std.html#a84149180e88153757ac3df08fe6dd3ce">00180</a> <span class="comment"></span>function cl_syoscb_queue_iterator_base cl_syoscb_queue_std::create_iterator();
<a name="l00181"></a>00181   cl_syoscb_queue_iterator_std result;
<a name="l00182"></a>00182 
<a name="l00183"></a>00183   <span class="comment">// Wait to get exclusive access to the queue</span>
<a name="l00184"></a>00184   <span class="comment">// if there are multiple iterators</span>
<a name="l00185"></a>00185   while(this.iter_sem.try_get() == 0);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187   result = cl_syoscb_queue_iterator_std::type_id::create(
<a name="l00188"></a>00188       $sformatf(&quot;%s_iter%0d&quot;, this.get_name(), this.iter_idx));
<a name="l00189"></a>00189 
<a name="l00190"></a>00190   <span class="comment">// No need to check return value since set_queue will issue</span>
<a name="l00191"></a>00191   <span class="comment">// and `uvm_error of something goes wrong</span>
<a name="l00192"></a>00192   void&apos;(result.set_queue(this));
<a name="l00193"></a>00193 
<a name="l00194"></a>00194   this.iterators[result] = result;
<a name="l00195"></a>00195   this.iter_idx++;
<a name="l00196"></a>00196   this.iter_sem.put();
<a name="l00197"></a>00197 
<a name="l00198"></a>00198   return result;
<a name="l00199"></a>00199 endfunction: create_iterator
<a name="l00200"></a>00200 <span class="comment"></span>
<a name="l00201"></a>00201 <span class="comment">/// &lt;b&gt;Queue API:&lt;/b&gt; See cl_syoscb_queue for more details</span>
<a name="l00202"></a><a class="code" href="classcl__syoscb__queue__std.html#ada80798fcd391e309e0e85f68cda98e1">00202</a> <span class="comment"></span>function bit cl_syoscb_queue_std::delete_iterator(cl_syoscb_queue_iterator_base iterator);
<a name="l00203"></a>00203   if(iterator == null) begin
<a name="l00204"></a>00204     `uvm_info(&quot;NULL&quot;, $sformatf(&quot;Asked to delete null iterator from list of iterators in %s&quot;,
<a name="l00205"></a>00205                                 this.get_name()), UVM_DEBUG);
<a name="l00206"></a>00206     return 0;
<a name="l00207"></a>00207   end else begin  
<a name="l00208"></a>00208     <span class="comment">// Wait to get exclusive access to the queue</span>
<a name="l00209"></a>00209     <span class="comment">// if there are multiple iterators</span>
<a name="l00210"></a>00210     while(!this.iter_sem.try_get());
<a name="l00211"></a>00211 
<a name="l00212"></a>00212     this.iterators.delete(iterator);
<a name="l00213"></a>00213     this.iter_idx--;
<a name="l00214"></a>00214     this.iter_sem.put();
<a name="l00215"></a>00215     return 1;
<a name="l00216"></a>00216   end
<a name="l00217"></a>00217 endfunction: delete_iterator
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<!--*************************************************************************-->
<!-- $Id: idv_dox_footer.html 136 2010-05-31 19:13:27Z seanoboyle $          -->
<!--*************************************************************************-->
<!--   This program is free software: you can redistribute it and/or modify  -->
<!--   it under the terms of the GNU General Public License as published by  -->
<!--   the Free Software Foundation, either version 3 of the License, or     -->
<!--   (at your option) any later version.                                   -->
<!--                                                                         -->
<!--   This program is distributed in the hope that it will be useful,       -->
<!--   but WITHOUT ANY WARRANTY; without even the implied warranty of        -->
<!--   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         -->
<!--   GNU General Public License for more details.                          -->
<!--                                                                         -->
<!--   You should have received a copy of the GNU General Public License     -->
<!--   along with this program.  If not, see http://www.gnu.org/licenses/.   -->
<!--                                                                         -->
<!--*************************************************************************-->
<!-- Title:        IDV Doxygen Footer File                                   -->
<!-- Description:  This file is a doxygen footer with the IDV logo and a     -->
<!--               and a reference to the GNU FDL License.                   -->
<!--                                                                         -->
<!-- Original Author: Sean O'Boyle                                           -->
<!-- Contact:         seanoboyle@intelligentdv.com                           -->
<!-- Company:         Intelligent Design Verification                        -->
<!-- Company URL:     http://intelligentdv.com                               -->
<!--                                                                         -->
<!-- Download the most recent version here:                                  -->
<!--                  http://intelligentdv.com/downloads                     -->
<!--                                                                         -->
<!-- File Bugs Here:  http://bugs.intelligentdv.com                          -->
<!--        Project:  DoxygenFilterSV                                        -->
<!--                                                                         -->
<!-- File: idv_dox_header.xml                                                -->
<!-- $LastChangedBy: seanoboyle $                                            -->
<!-- $LastChangedDate: 2010-05-31 12:13:27 -0700 (Mon, 31 May 2010) $        -->
<!-- $LastChangedRevision: 136 $                                             -->
<!--                                                                         -->
<!--*************************************************************************-->

<br>
<table border="1" width = "100%">
  <tr>
    <td width = "20%">
     <img src="syosil.jpg">
    </td>
    <td width = "60%">
       <address style="text-align: center;">
       Project: SyoSil ApS UVM Scoreboard, Revision: 1.0.2.4<br>
       <br>
       Copyright 2014-2015 SyoSil ApS<br>
       All Rights Reserved Worldwide<br>
       <br>
      Licensed under the Apache License, Version 2.0 (the "License"); you may not
      use this file except in compliance with the License.  You may obtain a copy of
      the License at<br>
      <br>
       <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a><br>
      <br>
      Unless required by applicable law or agreed to in writing, software distributed under the License is
      distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied. See the License for the specific language governing permissions and limitations under
      the License.
      </address>
    </td>
    <td width = "20%">
      <address style="text-align: right;"><small>
      <a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a><br>
      <a href="http://www.doxygen.org/index.html">Doxygen</a> Version: 1.6.1<br>
      <a href="http://www.intelligentdv.com/index.html">IDV SV Filter</a> Version: 2.6.2<br>
      Mon Oct 26 03:49:53 2015</small></address>
   </td>
  </tr>
</table>
<address style="text-align: left;"><small>
Find a documentation bug?  Report bugs to: <a href="http://bugs.intelligentdv.com/">bugs.intelligentdv.com</a> Project: DoxygenFilterSV
</small></address>
</body>
</html>
